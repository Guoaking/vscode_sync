# 创建型设计模式

>关注: 怎样创建对象?
>
>特点:
>
>1. 降低耦合度 : 将对象的*使用*和*创建*分离



## 1. 单例(Sigleton)

> 一个类只有一个实例，且该类能自行创建这个实例的一种模式。

### 1.应用场景

1. 需要频繁创建的类,使用单例可以降低系统内存压力,**减少GC** 
2. 只要求生成一个对象.
3. 某些类创建实例占用资源比较多,或者实例化耗时长,且经常使用
4. 需要频繁**实例化**,而对象被频繁销毁,eg: 多线程的线程池,网络连接池
5. 频繁访问数据库或文件对象
6. 当对象需要被**共享**的场合,eg:数据库连接池



> J2EE : ServletContext 和ServletContextConfig
>
> Spring: Application,数据库连接池
>
> Windows: 任务管理器,回收站,文件系统
>
> 公司CEO 部门经理

### 2.优点

1. 可以保证内存只有一个实例,减少了**内存的开销**
2. 避免对资源的多重占用
3. 单例模式设置全局访问点,可以优化和共享资源的访问

### 3.缺点

1. 一般没有接口,拓展困难.违背**开闭原则**
2. 并发测试中,不利于代码调式.,如果单例中代码没有执行完,也不能模拟生成一个新的对象
3. 代码通常写在一个class中,如果功能设计不合理,则容易违背**单一职责原则**



## 2. 原型(Prototype)

> 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。

###  1.应用场景

1. 对象之间**相同** 或者**相似**即只有几个属性不同的时候.
2. 创建对象**成本较大**,占用CPU太多,或者其他资源太多,需要**优化资源**的时候
3. 创建一个对象需要**繁琐**的数据准备或访问权限等,需要**提高性能**或者**安全**的时候
4. 系统中**大量使用**该对象,且各个调用都需要给他重新赋值的时候



> 在spring中 eg: scope='prototype' JSON.parseObject() 是原型模式的应用
>
> 在java中 eg: 有Cloneable接口 



### 2.优点

1. java自带的原型模式基于**内存二进制**流的赋值,**性能**上比new一个对象来的优良.
2. 可以使用**深克隆**的方式保存对象状态,**简化**对象创建流程,可辅助实现**撤销操作**

### 3.缺点

1. 需要为每一个类实现clone方法
2. 实现深克隆时,需要编写**复杂**代码,当对象存在**多重嵌套引用**时,实现起来有难度.



## 3. 静态工厂方法(Simple Factory)

> 简单工厂  松耦合

### 1.应用场景

1. 对于产品种类比较少的情况



> Spring : BeanFactory

### 2.优点

1. 工厂类包含必要的逻辑判断,可以决定在什么时候创建哪一个产品的实例,工厂和产品的职责区分明确
2. 客户端无需知道所创建的具体产品的类名,只需要知道参数即可
3. 可以引入配置文件,在不修改客户端代码的情况下更换和添加新的具体产品类

### 3.缺点

1. 工厂类单一,负责所有产品的创建,职责过重,工厂类代码容易臃肿,违背**高聚合原则**
2. 会增加系统中类的个数(引入新的工厂类),增加系统的复杂度和理解难度
3. 使用了static工厂方法,造成工厂角色无法形成**基于继承**的等级结构
4. 拓展困难,一旦增加新产品,就需要修改工厂逻辑,在产品类型较多时,可能造成逻辑过于复杂,每增加一个产品就需要增加了一个产品类和一个对应的工厂类,增加了系统复杂度,违背了**开闭原则**

## 4. 工厂方法(FactoryMethod) **类创建**

### 1.应用场景

1. 只要知道创建的工厂名,不需要具体的产品名
2. 创建对象任务由多个具体子工厂中的某一个完成,而抽象工厂只提供创建产品的接口
3. 客户不关心创建产品的细节,只关心品牌



> Spring : FactoryBean接口

### 2.优点

1. 可以使系统在不修改代码的情况下引进新的产品,符合**开闭原则** 
2. client只需要知道具体工厂的名称就可得到所要的产品,无需知道产品的创建过程
3. 灵活性强,对于新的产品的创建,只需要多写一个相应的工厂类
4. 解耦,高层模块只需要知道产品的抽象类,无需关心其他实现类,符合**迪米特法则** **依赖倒置** **里氏替换原则** 

### 3.缺点

1. 类的个数容易过多,增加复杂度
2. 增加了系统戴尔抽象性和理解难度
3. 抽象产品只能**生产一种**产品,可用抽象工厂解决

## 5. 抽象工厂(AbstractFactory)

> 是一种为访问类提供一个 创建一组相关或相互依赖对象的接口, 且访问类无须指定所要产品的具体类 就能得到同族的不通等级的产品的模式结构

### 1.应用场景

1. 当需要创建的对象是一系列相互关联或相互依赖的产品族时,
2. 系统中有多个产品族,但每次只使用其中某一族产品.
3. 系统中提供了产品的类库,且所有产品的接口相同,客户端不依赖产品实例的创建细节和内部结构



> 创建不同操作系统的视窗构建 
>
> java :AWT 中Button 在Windows和UnIX中的实现不同



### 2.优点

1. 可以在类的内部对产品族中相关联的多等级产品共同管理,而不必引入新的类来进行管理
2. 当需要产品族时,抽象工厂可以保证客户端始终只使用同一个产品的产品组
3. 抽象工厂增强了程序的可拓展性,当增加一个新的产品族时,不需要修改源代码,满足**开闭原则**

### 3.缺点

1. 当产品族中需要增加一个新的产品时,所有的工厂类都需要进行修改.增加了系统的抽象性和理解难度.

## 6. 建造者模式(Builder)

> 将一个复杂对象的构造和它的表示分离,使同样的构建过程可以创建不同的表示.
>
> 主要关注零部件的组装过程,工厂方法注重零部件的创建过程.

#### 建造者与工厂模式的区别

* 更注重方法的调用顺序,工厂注重创建对象
* 创建对象的力度不同,建造者创建复杂对象,由各种复杂的部件组成,而工厂模式创建出来的对象都一样
* 关注重点不一样,工厂模式只需要把对象创建出来即可,建造者模式不仅要创建对象,还要知道对象由哪些部件组成
* 建造者模式根据建造过程中顺序的不一样,最终对象部件组成也不一样

### 1.应用场景

1. 相同的方法,不同的**执行顺序** 不同的结果
2. 多个部件或零件,都可以装配到一个对象中,但产生的**结果**又不相同
3. 产品类比较**复杂**,或者产品类中不太的调用顺序产生不同的**作用** 
4. 初始化一个对象特别复杂,参数多,而且很多参数都有**默认值** 

### 2.优点

1. 封装性好,构建和表示分离
2. 拓展性好,建造者相互独立,有利于系统解耦
3. 客户端不必知道产品内部组成的细节,可以对创建过程逐步细化,而不对其他模块产生影响,便于控制细节风险

### 3.缺点

1. 产品的组成部门必须相同,这限制了其使用范围
2. 产品的内部变化复杂,则建造者也要同步修改,后期**维护成本大** 
3. 