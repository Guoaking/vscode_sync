# 结构型模型

> 用来描述如何将类或对象按某种布局组成更大的结构.



**对象型**

## 1. 代理(Proxy)

> 由于某些原因需要给某对象提供一个代理对象以控制对象的访问. 这时,访问对象不合适或者不能直接引用目标对象,代理对象作为访问对象和目标对象之间的中介
>
> 保护目标对象 
>
> 增强目标对象

### 1.应用场景

1. 远程代理,这种方式通常是为了隐藏目标对象存在于不同地址空间的事实,方便客户端访问.
2. 虚拟代理,通常用于要创建的目标对象开销很大时.
3. 安全代理,通常用于控制不同种类客户对真是对象的访问权限
4. 智能指引,主要用于调用目标对象时,代理附加一些额外的处理功能.
5. 延迟加载,为了提高系统的性能,延迟对目标的加载. Hibernate

> Spring: AOP底层

### 2.优点

1. 在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
2. 代理对象可以拓展目标对象的功能
3. 代理模式能将客户端与目标对象分离,在一定程度上降低了系统的耦合度,增加了程序的可拓展性

### 3.缺点 静态

1. 代理模式会造成系统设计中类的数量增加
2. 在客户端和目标对象之间增加一个代理对象,会造成请求处理速度变慢;
3. 增加了系统复杂度







## 2. 桥接(Brideg)

### 1.应用场景



### 2.优点



### 3.缺点



## 3. 装饰(Decorator)

> 在不改变现在对象结构的情况下,动态给该对象增加一些职责 

### 1.应用场景

1. 当需要给一个现有类添加附加职责,而又不能采用生成子类的方法进行扩充时. eg: 该类被隐藏,或者是终极类,或者采用继承方式会产生大量的子类
2. 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时,采用继承很难实现
3. 对象的功能要求可以动态添加,也可以动态的撤销.



> java : java I/O 标准库设计 inputStream outputStream BufferedReader BufferedWriter FilterReader PrintWriter
>
> Spring: 类名有Wrapper, 和 Decorator

### 2.优点

1. 是继承有力的补充,比继承灵活,在不改变原来对象的情况下,动态的给一个对象拓展功能,即插即用
2. 通过使用不同装饰器类以及这些装饰类的排列组合,可以实现不同效果
3. 遵守**开闭原则** 

### 3.缺点

1. 会增加需要子类,过度使用会增加程序复杂性



## 4. 外观(Facade)

### 1.应用场景



### 2.优点



### 3.缺点



## 5. 享元(Flyweight)

> 运用共享技术来有效地支持大量**细粒度** 对象的复用.通过共享已经存在的对象来大幅度减少需要创建的对象数量,避免大量相似类的开销,从而提高系统资源的利用率.

### 1.应用场景

1. 系统中存在大量相同或者相似的对象,这些对象耗费大量的内存资源
2. 大部分的对象可以按照内部状态进行分组,且可将不同部分外部化,这样每一个组只需要保存一个内容状态
3. 由于享元模式需要额外维护一个保存享元的数据结构,所以应当在有足够多的享元实例时才值得使用.
4. 是**工厂方法模式** 的一个改进,为此模式增加了**缓存** 这一功能

### 2.优点

1. 相同的对象只要保存一份**单例?** ,这降低了系统中对象的数量,从而降低了系统中细粒度对象给内存带来的压力 

### 3.缺点

1. 为了使对象可以共享,需要将一些不能共享的状态外部化,增加了程序的复杂性
2. 读取享元模式的外部状态会使得运行时间稍微变长.





## 6. 组合(Composite)

### 1.应用场景



### 2.优点



### 3.缺点



**类结构and对象结构**

## 7. 适配器模式(Adapter)

> 将一个类的接口转换成客户希望的另外一个接口,使得原本由于结构不兼容而不能一起工作的那些类能一起工作. 

### 1.应用场景

1. 以前开发的系统存在满足新系统功能需求的物类, 但其接口同新系统的接口不一致.
2. 使用第三方提供的组件,但组件接口定义和自己要求的接口定义不同

> SpringMVC: HandlerAdatper

### 2.优点

1. 客户端通过适配器可以透明的调用目标接口
2. 复用了现存的类,程序员不需要修改原有代码而重用现有的适配者类.
3. 将目标类和适配者类解耦,解决了目标类和适配者类接口不一致的问题.
4. 在很多业务场景中符合**开闭原则** 

### 3.缺点

1. 适配器编写过程需要结合业务场景全面考虑,可能会增加系统的复杂性
2. 增加代码阅读难度,降低代码可读性,过多使用适配器会使系统代码变得凌乱