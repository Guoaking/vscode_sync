# 行为型设计模式

>用于描述程序在运行时的复杂流程控制,即描述多个类或者对象之间怎样像话剖哦共同完成单个对象无法单独完成的任务,涉及算法和对象的职责分配

---





**类行为: 继承机制来在类间分派行为** 



## 1. 模板方法(Template Method)

> 定义一个操作中的算法骨架,将算法的一些步骤延迟到子类中,使得子类可以不改变算法结构的情况下重定义改算法的某些特定步骤.

### 1.应用场景

1. 算法的整体步骤很固定,但其中个别部分易变,(提供子类的实现)
2. 多个子类存在公共行为时,可以提取出来到一个公共父类中,避免代码重复
3. 当需要控制子类的拓展时,模板方法只在特定点调用钩子操作,这样就只允许在这些点进行拓展

> Spring : 模板和回调的结合, JDBC的抽象和对Hibernate的集成
>
> Spring : 集中的方式来处理资源的获取和释放

### 2.优点

1. 封装了不可变得部分,拓展可变得部分.便于子类继续拓展.
2. 在父类中提取了公共的部分代码,便于**代码复用** 
3. 部分方法是由子类实现的,子类可以通过拓展的方式增加相应的功能,符合**开闭原则** 

### 3.缺点

1. 对不同的实现都需要一个子类,导致类的个数增加,系统更加庞大,设计更加抽象,间接地增加了系统的实现的复杂度
2. 父类中的抽象方法由子类实现,子类执行的结构会影响父类的结果,这导致一种反向控制结构,提高了代码阅读的难度
3. 继承的缺点,如果父类添加新的抽象方法,则所有的子类都要修改一遍



## 2. 解释器(interpreter)

### 1.应用场景



### 2.优点



### 3.缺点



**对象行为: 采用组合或聚合在对象间分配行为 (合成复用原则) 具有更大的灵活性**

## 3. 策略(Strategy)

> 定义一系列算法,并将每个算法封装起来,使他们可以相互替换,且算法的变化不会影响使用算法的用户.

### 1.应用场景

1. 一个系统需要动态地在几种算法中选择一种时,可以将每个算法封装到策略类中
2. 一个类定义了多种行为,并且 这些行为在这个类的操作中以多个条件语句的形式出现,可将每个**条件分支** 移入他们各自的策略类中以代替这些条件语句
3. 系统中算法彼此完全独立,且要求对客户隐藏具体算法的实现细节时.
4. 系统要求使用算法的客户不应该知道其操作的数据时,可使用策略模式来**隐藏**与算法相关的数据结构
5. 多个类只区别在**表现行为** 不同,可以使用策略模式,在运行时动态选择具体要执行的行为



> java SE : 容器布局管理,
>
> Spring : 资源访问的Resource接口 需要的实现类

### 2.优点

1. 多重条件语句不易维护, 而使用策略模式可以避免使用多重条件语句,if...else switch..case语句
2. 提供了一系列可供重用的算法族,恰当使用继承可以吧算法族的公共代码转义到父类里面,从而**避免重复代码** 
3. 可以提供相同行为的不同实现,客户可以根据不同的时间或空间要求选择不同的
4. 对**开闭原则** 的完美支持,可以在不修改源代码的情况下,灵活增加新算法
5. 把算法的使用放到环境类中,而算法的实现移到策略类中,实现了二者的分离

### 3.缺点

1. client必须理解所有策略算法的区别,以便选择
2. 有很多的策略类,增加维护难度



## 4. 命令(Command)

### 1.应用场景



### 2.优点



### 3.缺点



## 5. 职责链(Chain of Responsibility)

### 1.应用场景



### 2.优点



### 3.缺点



## 6. 观察者(Observer)

> 多个对象间存在**一对多** 的依赖关系, 当一个对象的状态发生改变时,所有依赖他的对象都得到通知并被**自动** 更新. 发布-订阅模式

### 1.应用场景

> java: Observer Observable 接口 setChanged(); notifyObservers();
>
> spring: 事件驱动模型 listener的实现
>
> 组件是事件源->目标对象, 事件处理程序类的对象是具体观察者对象

### 2.优点

1. 降低了目标与观察者之间的耦合关系,两者之间是抽象耦合关系.符合**依赖倒置** 原则
2. 目标与观察者之间建立了一套触发机制

### 3.缺点

1. 目标与观察者之间的依赖关系没有完全解除,而且有可能出现循环引用
2. 当观察者对象很多时,通知的发布会花费很多时间,影响程序的**效率** 



## 7. 中介者(Mediator)

### 1.应用场景



### 2.优点



### 3.缺点



## 8. 迭代器(lterator)

### 1.应用场景



### 2.优点



### 3.缺点



## 9. 访问者(Visitor)

### 1.应用场景



### 2.优点



### 3.缺点



## 10. 备忘录(Memento)

### 1.应用场景



### 2.优点



### 3.缺点



## 11. 状态(State)

### 1.应用场景



### 2.优点



### 3.缺点

